package shjscx;

import javax.xml.transform.Result;
import java.util.*;

//刷伤害的计算
public class JiShuanZhiFu {
    //虽然你错了，但是我愿意给你改过的机会
    public static void JiHui() {
        System.out.println("感谢您的使用，等您想好了欢迎您的再次使用");
        System.out.println("哈哈哈，开玩笑！我决定再给你一次机会！\n");
    }

    //存放魔化战斗叠加的重复数据，减少代码冗余
    public static double MoHuaPiChuan(double a) {
        System.out.println("劈砍/穿刺值为:" + a);
        double g = 1.24;
        return g;
    }

    public static double ZhanDouMingZhong(double a) {
        System.out.println("当前命中为:" + a);
        double g = 1.26;
        return g;
    }

    public static void MoHua(double b, double c, double a, double c1) {
        System.out.printf("【当前的回合:%d】\n", b);
        System.out.printf("当前所叠加的值:%d\n", c);
        System.out.printf("当前的劈砍(穿刺)值:%d\n", a);
        if (b >= 5) {
            System.out.printf("顶的值%d\n", c1);
        }
    }

    public static void ZhanDou(double b, double c, double a, double c1) {
        System.out.printf("【当前的回合:%d】\n", b);
        System.out.printf("当前所叠加的值:%d\n", c);
        System.out.printf("当前的命中:%d\n", a);
        if (b >= 4) {
            System.out.printf("顶的值%d\n", c1);
        }
    }

    //魔化计算
    //战斗命中计算(单战斗命中计算使用的是魔化内核)
    public static void HunZhiJiSuan(double a, int xz1) {
        double b = 0, c = 0, d = 0;
        double e = 0, f = 0, g = 0, h, i, j, k = 1000000;
        double a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0;
        //叠加魔化(a后面的值为返回的伦数)
        double d1 = 0, d2 = 0, d3 = 0, d4 = 0, d5 = 0;
        //返回值(b后面得值为返回的伦数)
        double c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0;
        //叠加得值(c后面得值为返回的伦数)
        if (xz1 == 1) {
            g = MoHuaPiChuan(a);
        } else {
            g = ZhanDouMingZhong(a);
        }
        a1 = a2 = a3 = a4 = a5 = a;
        //保存a的初值
        while (b < 5) {
            if (a >= k) {
                break;
            }
            b++;//回合
            //魔化持续5回合
            if (b % 2 != 0) {
                d = a;//保存a的返回值
                a = a * g;//叠魔化得值
                c = a - d;//叠加的值
            }
            if (xz1 == 1) {
                MoHua(b, c, a, c1);
            } else {
                ZhanDou(b, c, a, c1);
            }
        }
        while (b < 10) {
            if (a >= k) {
                break;
            }
            b++;//回合
            if (b % 2 != 0) {
                d1 = a1;//保存e的返回值(第一轮顶得值)
                a1 = a1 * g;//魔化叠加(第一轮顶得值)
                c1 = a1 - d1;//叠加的值(第一轮顶得值)

                d = a - c1;//保存a的返回值
                a = (a - c1) * g;//魔化叠加
                c = a - d;//叠加的值
            }
            if (xz1 == 1) {
                MoHua(b, c, a, c1);
            } else {
                ZhanDou(b, c, a, c1);
            }
        }
        while (b < 15) {
            if (a >= k) {
                break;
            }
            b++;//回合
            if (b % 2 != 0) {
                d2 = a2;//保留a2的返回值(第二轮顶得值)
                a2 = a2 * g;//魔化叠加(第二轮顶得值)
                c2 = a2 - d2;//叠加的值(第二轮顶的值)

                d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
                a1 = (a1 - c2) * g;//魔化叠加(第一轮轮顶得值)
                c1 = a1 - d1;//叠加的值(第一轮顶的值)

                d = a - c1;//保存a的返回值
                a = (a - c1) * g;//魔化叠加
                c = a - d;//叠加的值
            }
            if (xz1 == 1) {
                MoHua(b, c, a, c1);
            } else {
                ZhanDou(b, c, a, c1);
            }
        }
        while (b < 20) {
            if (a >= k) {
                break;
            }
            b++;//回合
            if (b % 2 != 0) {
                d3 = a3;//保留a3的返回值(第三轮顶的值)
                a3 = a3 * g;//魔化叠加(第三轮顶的值)
                c3 = a3 - d3;//顶得值(第三轮顶的值)

                d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
                a2 = (a2 - c3) * g;//魔化叠加(第二轮顶得值)
                c2 = a2 - d2;//叠加的值(第二轮顶的值)

                d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
                a1 = (a1 - c2) * g;//魔化叠加(第一轮轮顶得值)
                c1 = a1 - d1;//叠加的值(第一轮顶的值)

                d = a - c1;//保存a的返回值
                a = (a - c1) * g;//魔化叠加
                c = a - d;//叠加的值
            }
            if (xz1 == 1) {
                MoHua(b, c, a, c1);
            } else {
                ZhanDou(b, c, a, c1);
            }
        }
        while (b < 25) {
            if (a >= k) {
                break;
            }
            b++;//回合
            if (b % 2 != 0) {
                d4 = a4;//保留a4的返回值(第四轮顶的值)
                a4 = a4 * g;//魔化叠加的值(第四轮顶的值)
                c4 = a4 - d4;//顶的值(第四轮顶的值)

                d3 = a3 - c4;//保留a3的返回值(第三轮顶的值)
                a3 = (a3 - c4) * g;//魔化叠加(第三轮顶的值)
                c3 = a3 - d3;//顶得值(第三轮顶的值)

                d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
                a2 = (a2 - c3) * g;//魔化叠加(第二轮顶得值)
                c2 = a2 - d2;//叠加的值(第二轮顶的值)

                d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
                a1 = (a1 - c2) * g;//魔化叠加(第一轮轮顶得值)
                c1 = a1 - d1;//叠加的值(第一轮顶的值)

                d = a - c1;//保存a的返回值
                a = (a - c1) * g;//魔化叠加
                c = a - d;//叠加的值
            }
            if (xz1 == 1) {
                MoHua(b, c, a, c1);
            } else {
                ZhanDou(b, c, a, c1);
            }
        }
        while (b < 30) {
            if (a >= k) {
                break;
            }
            b++;//回合
            if (b % 2 != 0) {
                d5 = a5;//保留a5的返回值(第五轮顶的值)
                a5 = a5 * g;//魔化叠加的值(第五轮顶的值)
                c5 = a5 - d5;//顶的值(第五轮顶的值)

                d4 = a4 - c5;//保留a4的返回值(第四轮顶的值)
                a4 = (a4 - c5) * g;//魔化叠加的值(第四轮顶的值)
                c4 = a4 - d4;//顶的值(第四轮顶的值)

                d3 = a3 - c4;//保留a3的返回值(第三轮顶的值)
                a3 = (a3 - c4) * g;//魔化叠加(第三轮顶的值)
                c3 = a3 - d3;//顶得值(第三轮顶的值)

                d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
                a2 = (a2 - c3) * g;//魔化叠加(第二轮顶得值)
                c2 = a2 - d2;//叠加的值(第二轮顶的值)

                d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
                a1 = (a1 - c2) * g;//魔化叠加(第一轮轮顶得值)
                c1 = a1 - d1;//叠加的值(第一轮顶的值)

                d = a - c1;//保存a的返回值
                a = (a - c1) * g;//魔化叠加
                c = a - d;//叠加的值
            }
            if (xz1 == 1) {
                MoHua(b, c, a, c1);
            } else {
                ZhanDou(b, c, a, c1);
            }
        }
    }

    public static void DanZhiJiSuan(double a, int xz1) {
        double b = 0, c = 0, d = 0;
        double e = 0, f = 0, g = 0, h, i, j, k = 1000000;
        double a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0;
        //叠加魔化(a后面的值为返回的伦数)
        double d1 = 0, d2 = 0, d3 = 0, d4 = 0, d5 = 0;
        //返回值(b后面得值为返回的伦数)
        double c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0;
        //叠加得值(c后面得值为返回的伦数)
        if (xz1 == 1) {
            g = MoHuaPiChuan(a);
        } else {
            g = ZhanDouMingZhong(a);
        }
        a1 = a2 = a3 = a4 = a5 = a;
        //保存a的初值
        while (b < 5) {
            if (a >= k) {
                break;
            }
            //魔化持续5回合
            d = a;//保存a的返回值
            a = a * g;//叠魔化得值
            b++;//回合
            c = a - d;//叠加的值
            if (xz1 == 1) {
                MoHua(b, c, a, c1);
            } else {
                ZhanDou(b, c, a, c1);
            }
        }
        while (b < 10) {
            if (a >= k) {
                break;
            }
            b++;//回合
            d1 = a1;//保存e的返回值(第一轮顶得值)
            a1 = a1 * g;//魔化叠加(第一轮顶得值)
            c1 = a1 - d1;//叠加的值(第一轮顶得值)
            d = a - c1;//保存a的返回值
            a = (a - c1) * g;//魔化叠加
            c = a - d;//叠加的值
            if (xz1 == 1) {
                MoHua(b, c, a, c1);
            } else {
                ZhanDou(b, c, a, c1);
            }
        }
        while (b < 15) {
            if (a >= k) {
                break;
            }
            b++;//回合
            d2 = a2;//保留a2的返回值(第二轮顶得值)
            a2 = a2 * g;//魔化叠加(第二轮顶得值)
            c2 = a2 - d2;//叠加的值(第二轮顶的值)
            d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
            a1 = (a1 - c2) * g;//魔化叠加(第一轮轮顶得值)
            c1 = a1 - d1;//叠加的值(第一轮顶的值)
            d = a - c1;//保存a的返回值
            a = (a - c1) * g;//魔化叠加
            c = a - d;//叠加的值
            if (xz1 == 1) {
                MoHua(b, c, a, c1);
            } else {
                ZhanDou(b, c, a, c1);
            }
        }
        while (b < 20) {
            if (a >= k) {
                break;
            }
            b++;//回合
            d3 = a3;//保留a3的返回值(第三轮顶的值)
            a3 = a3 * g;//魔化叠加(第三轮顶的值)
            c3 = a3 - d3;//顶得值(第三轮顶的值)
            d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
            a2 = (a2 - c3) * g;//魔化叠加(第二轮顶得值)
            c2 = a2 - d2;//叠加的值(第二轮顶的值)
            d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
            a1 = (a1 - c2) * g;//魔化叠加(第一轮轮顶得值)
            c1 = a1 - d1;//叠加的值(第一轮顶的值)
            d = a - c1;//保存a的返回值
            a = (a - c1) * g;//魔化叠加
            c = a - d;//叠加的值
            if (xz1 == 1) {
                MoHua(b, c, a, c1);
            } else {
                ZhanDou(b, c, a, c1);
            }
        }
        while (b < 25) {
            if (a >= k) {
                break;
            }
            b++;//回合
            d4 = a4;//保留a4的返回值(第四轮顶的值)
            a4 = a4 * g;//魔化叠加的值(第四轮顶的值)
            c4 = a4 - d4;//顶的值(第四轮顶的值)
            d3 = a3 - c4;//保留a3的返回值(第三轮顶的值)
            a3 = (a3 - c4) * g;//魔化叠加(第三轮顶的值)
            c3 = a3 - d3;//顶得值(第三轮顶的值)
            d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
            a2 = (a2 - c3) * g;//魔化叠加(第二轮顶得值)
            c2 = a2 - d2;//叠加的值(第二轮顶的值)
            d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
            a1 = (a1 - c2) * g;//魔化叠加(第一轮轮顶得值)
            c1 = a1 - d1;//叠加的值(第一轮顶的值)
            d = a - c1;//保存a的返回值
            a = (a - c1) * g;//魔化叠加
            c = a - d;//叠加的值
            if (xz1 == 1) {
                MoHua(b, c, a, c1);
            } else {
                ZhanDou(b, c, a, c1);
            }
        }
        while (b < 30) {
            if (a >= k) {
                break;
            }
            b++;//回合
            d5 = a5;//保留a5的返回值(第五轮顶的值)
            a5 = a5 * g;//魔化叠加的值(第五轮顶的值)
            c5 = a5 - d5;//顶的值(第五轮顶的值)
            d4 = a4 - c5;//保留a4的返回值(第四轮顶的值)
            a4 = (a4 - c5) * g;//魔化叠加的值(第四轮顶的值)
            c4 = a4 - d4;//顶的值(第四轮顶的值)
            d3 = a3 - c4;//保留a3的返回值(第三轮顶的值)
            a3 = (a3 - c4) * g;//魔化叠加(第三轮顶的值)
            c3 = a3 - d3;//顶得值(第三轮顶的值)
            d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
            a2 = (a2 - c3) * g;//魔化叠加(第二轮顶得值)
            c2 = a2 - d2;//叠加的值(第二轮顶的值)
            d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
            a1 = (a1 - c2) * g;//魔化叠加(第一轮轮顶得值)
            c1 = a1 - d1;//叠加的值(第一轮顶的值)
            d = a - c1;//保存a的返回值
            a = (a - c1) * g;//魔化叠加
            c = a - d;//叠加的值
            if (xz1 == 1) {
                MoHua(b, c, a, c1);
            } else {
                ZhanDou(b, c, a, c1);
            }
        }
    }

    public static void YiGeBanZhiJiSuan(double a, int xz1) {
        double b = 0, c = 0, d = 0;
        double a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0, a6 = 0, a7 = 0;
        //叠加战斗(a后面的值为返回的伦数)
        double d1 = 0, d2 = 0, d3 = 0, d4 = 0, d5 = 0, d6 = 0, d7 = 0;
        //返回值(b后面得值为返回的伦数)
        double g = 1.26;//战斗叠加
        double c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
        //叠加得值(c后面得值为返回的伦数)
        g = ZhanDouMingZhong(a);
        a1 = a2 = a3 = a4 = a5 = a6 = a7 = a;
        //保存a的初值
        while (b < 4) {
            //战斗持续4回合
            b++;//回合
            if (b % 2 == 0) {
                g = g * g;
            }
            d = a;//保存a的返回值
            a = a * g;//战斗叠加的值
            c = a - d;//叠加的值
            if (b % 2 == 0) {
                g = g / 1.26;
            }
            ZhanDou(b, c, a, c1);
        }
        while (b < 8) {
            b++;//回合
            if (b % 2 == 0) {
                g = g * g;
            }
            d1 = a1;//保存e的返回值(第一轮顶得值)
            a1 = a1 * g;//战斗叠加(第一轮顶得值)
            c1 = a1 - d1;//叠加的值(第一轮顶得值)
            d = a - c1;//保存a的返回值
            a = (a - c1) * g;//战斗叠加
            c = a - d;//叠加的值
            if (b % 2 == 0) {
                g = g / 1.26;
            }
            ZhanDou(b, c, a, c1);
        }
        while (b < 12) {
            //回合
            b++;
            if (b % 2 == 0) {
                g = g * g;
            }
            d2 = a2;//保留a2的返回值(第二轮顶得值)
            a2 = a2 * g;//战斗叠加(第二轮顶得值)
            c2 = a2 - d2;//叠加的值(第二轮顶的值)
            d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
            a1 = (a1 - c2) * g;//战斗叠加(第一轮轮顶得值)
            c1 = a1 - d1;//叠加的值(第一轮顶的值)
            d = a - c1;//保存a的返回值
            a = (a - c1) * g;//战斗叠加
            c = a - d;//叠加的值
            if (b % 2 == 0) {
                g = g / 1.26;
            }
            ZhanDou(b, c, a, c1);
        }
        while (b < 16) {
            b++;
            if (b % 2 == 0) {
                g = g * g;
            }
            d3 = a3;//保留a3的返回值(第三轮顶的值)
            a3 = a3 * g;//战斗叠加(第三轮顶的值)
            c3 = a3 - d3;//顶得值(第三轮顶的值)
            d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
            a2 = (a2 - c3) * g;//战斗叠加(第二轮顶得值)
            c2 = a2 - d2;//叠加的值(第二轮顶的值)
            d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
            a1 = (a1 - c2) * g;//战斗叠加(第一轮轮顶得值)
            c1 = a1 - d1;//战斗的值(第一轮顶的值)
            d = a - c1;//保存a的返回值
            a = (a - c1) * g;//战斗叠加
            c = a - d;//叠加的值
            if (b % 2 == 0) {
                g = g / 1.26;
            }
            ZhanDou(b, c, a, c1);
        }
        while (b < 20) {
            b++;
            if (b % 2 == 0) {
                g = g * g;
            }
            d4 = a4;//保留a4的返回值(第四轮顶的值)
            a4 = a4 * g;//战斗叠加的值(第四轮顶的值)
            c4 = a4 - d4;//顶的值(第四轮顶的值)
            d3 = a3 - c4;//保留a3的返回值(第三轮顶的值)
            a3 = (a3 - c4) * g;//战斗叠加(第三轮顶的值)
            c3 = a3 - d3;//顶得值(第三轮顶的值)
            d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
            a2 = (a2 - c3) * g;//战斗叠加(第二轮顶得值)
            c2 = a2 - d2;//叠加的值(第二轮顶的值)
            d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
            a1 = (a1 - c2) * g;//战斗叠加(第一轮轮顶得值)
            c1 = a1 - d1;//叠加的值(第一轮顶的值)
            d = a - c1;//保存a的返回值
            a = (a - c1) * g;//战斗叠加
            c = a - d;//叠加的值
            if (b % 2 == 0) {
                g = g / 1.26;
            }
            ZhanDou(b, c, a, c1);
        }
        while (b < 24) {
            b++;
            if (b % 2 == 0) {
                g = g * g;
            }
            d5 = a5;//保留a5的返回值(第五轮顶的值)
            a5 = a5 * g;//战斗叠加的值(第五轮顶的值)
            c5 = a5 - d5;//顶的值(第五轮顶的值)
            d4 = a4 - c5;//保留a4的返回值(第四轮顶的值)
            a4 = (a4 - c5) * g;//战斗叠加的值(第四轮顶的值)
            c4 = a4 - d4;//顶的值(第四轮顶的值)
            d3 = a3 - c4;//保留a3的返回值(第三轮顶的值)
            a3 = (a3 - c4) * g;//战斗叠加(第三轮顶的值)
            c3 = a3 - d3;//顶得值(第三轮顶的值)
            d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
            a2 = (a2 - c3) * g;//战斗叠加(第二轮顶得值)
            c2 = a2 - d2;//叠加的值(第二轮顶的值)
            d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
            a1 = (a1 - c2) * g;//战斗叠加(第一轮轮顶得值)
            c1 = a1 - d1;//叠加的值(第一轮顶的值)
            d = a - c1;//保存a的返回值
            a = (a - c1) * g;//战斗叠加
            c = a - d;//叠加的值
            if (b % 2 == 0) {
                g = g / 1.26;
            }
            ZhanDou(b, c, a, c1);
        }
        while (b < 28) {
            b++;
            if (b % 2 == 0) {
                g = g * g;
            }
            d6 = a6;//保存a的返回值
            a6 = a6 * g;//战斗叠加
            c6 = a6 - d6;//叠加的值
            d5 = (a5 - c6);//保留a5的返回值(第五轮顶的值)
            a5 = (a5 - c6) * g;//战斗叠加的值(第五轮顶的值)
            c5 = a5 - d5;//顶的值(第五轮顶的值)
            d4 = a4 - c5;//保留a4的返回值(第四轮顶的值)
            a4 = (a4 - c5) * g;//战斗叠加的值(第四轮顶的值)
            c4 = a4 - d4;//顶的值(第四轮顶的值)
            d3 = a3 - c4;//保留a3的返回值(第三轮顶的值)
            a3 = (a3 - c4) * g;//战斗叠加(第三轮顶的值)
            c3 = a3 - d3;//顶得值(第三轮顶的值)
            d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
            a2 = (a2 - c3) * g;//战斗叠加(第二轮顶得值)
            c2 = a2 - d2;//叠加的值(第二轮顶的值)
            d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
            a1 = (a1 - c2) * g;//战斗叠加(第一轮轮顶得值)
            c1 = a1 - d1;//叠加的值(第一轮顶的值)
            d = a - c1;//保存a的返回值
            a = (a - c1) * g;//战斗叠加
            c = a - d;//叠加的值
            if (b % 2 == 0) {
                g = g / 1.26;
            }
            ZhanDou(b, c, a, c1);
        }
        while (b < 30) {
            b++;
            if (b % 2 == 0) {
                g = g * g;
            }
            d7 = a7;//保存a的返回值
            a7 = a7 * g;//战斗叠加
            c7 = a7 - d7;//叠加的值
            d6 = a6 - c7;//保存a的返回值
            a6 = (a6 - c7) * g;//战斗叠加
            c6 = a6 - d6;//叠加的值
            d5 = (a5 - c6);//保留a5的返回值(第五轮顶的值)
            a5 = (a5 - c6) * g;//战斗叠加的值(第五轮顶的值)
            c5 = a5 - d5;//顶的值(第五轮顶的值)
            d4 = a4 - c5;//保留a4的返回值(第四轮顶的值)
            a4 = (a4 - c5) * g;//魔化叠加的值(第四轮顶的值)
            c4 = a4 - d4;//顶的值(第四轮顶的值)
            d3 = a3 - c4;//保留a3的返回值(第三轮顶的值)
            a3 = (a3 - c4) * g;//战斗叠加(第三轮顶的值)
            c3 = a3 - d3;//顶得值(第三轮顶的值)
            d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
            a2 = (a2 - c3) * g;//战斗叠加(第二轮顶得值)
            c2 = a2 - d2;//叠加的值(第二轮顶的值)
            d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
            a1 = (a1 - c2) * g;//战斗叠加(第一轮轮顶得值)
            c1 = a1 - d1;//叠加的值(第一轮顶的值)
            d = a - c1;//保存a的返回值
            a = (a - c1) * g;//战斗叠加
            c = a - d;//叠加的值
            if (b % 2 == 0) {
                g = g / 1.26;
            }
            ZhanDou(b, c, a, c1);
        }
    }

    //战斗计算
    public static void DanZhanDouJiSuan(double a) {
        double b = 0, c = 0, d = 0, e = 0;
        System.out.println("劈砍穿刺值为:" + a);
        while (a <= 1000000) {
            c++;
            if (c > 30) {
                break;
            }
            b = a - e;//保留a上一回合的值
            d = e;//保留上一回合叠加的值
            a = (a - d) * 1.4;//叠加战斗
            e = a - b;//战斗所叠加的值
            System.out.printf("【当前为:第%d回合】\n", c);
            System.out.printf("顶掉的值(上一回合叠加值):%d\n", d);
            System.out.printf("本回合叠加的值:%d\n", e);
            System.out.printf("当前的穿刺值:%d\n", a);
        }
    }

    //魔化+战斗叠加
    //魔化战斗工具包
    public static void MoHuaZhanDouGongJuBao(double d, double a, double c, double f, double g, double c1) {
        System.out.printf("【当前的回合%d】\n", d);
        System.out.printf("当前的劈砍(穿刺)值%d\n", a);
        System.out.printf("魔化叠加的值:%d\n", c);
        System.out.printf("战斗叠加得值%d\n", f);
        System.out.printf("顶的战斗值%d\n", g);
        if (d >= 5) {
            System.out.printf("魔化顶的值为:%d\n", c1);
        }
    }

    public static void MoHuaZanDouDieJia(double a) {
        double a1, a2, a3, a4, a5;
        double b = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0;
        double c = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0;
        double e = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0, e5 = 0;
        double f = 0, f1 = 0, f2 = 0, f3 = 0, f4 = 0, f5 = 0;
        double d = 0, h = 1000000, g;
        System.out.println("劈砍/穿刺值为:" + a);
        a1 = a2 = a3 = a4 = a5 = a;
        while (d < 5) {
            if (a >= h) {
                break;
            }
            d++;
            b = a;//保留a的返回值
            a = a * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 10) {
            if (a >= h) {
                break;
            }
            d++;
            b1 = a1;//保留a的返回值
            a1 = a1 * 1.24;//叠加魔化
            c1 = a1 - b1;//魔化叠加的值
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加魔化
            f1 = a1 - e1;//叠加魔化的值
            b = (a - c1);//保留a的返回值
            a = (a - c1) * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 15) {
            if (a >= h) {
                break;
            }
            d++;
            b2 = a2;//保留a2的返回值
            a2 = a2 * 1.24;//叠加魔化
            c2 = a2 - b2;//魔化叠加的值
            e2 = a2 - f2;//保留a2上一回合的值
            a2 = (a2 - f2) * 1.4;//叠加战斗
            f2 = a2 - e2;//战斗叠加的值
            b1 = (a1 - c2);//保留a1的返回值
            a1 = (a1 - c2) * 1.24;//叠加魔化
            c1 = a1 - b1;//叠加的值
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加战斗
            f1 = a1 - e1;//战斗叠加的值
            b = (a - c1);//保留a的返回值
            a = (a - c1) * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 20) {
            if (a >= h) {
                break;
            }
            d++;
            b3 = a3;//保留a3的返回值
            a3 = a3 * 1.24;//叠加魔化
            c3 = a3 - b3;//魔化叠加的值
            e3 = a3 - f3;//保留a3上一回合的值
            a3 = (a3 - f3) * 1.4;//叠加战斗
            f3 = a3 - e3;//战斗叠加的值
            b2 = (a2 - c3);//保留a2的返回值
            a2 = (a2 - c3) * 1.24;//叠加魔化
            c2 = a2 - b2;//魔化叠加的值
            e2 = a2 - f2;//保留a2上一回合的值
            a2 = (a2 - f2) * 1.4;//叠加战斗
            f2 = a2 - e2;//战斗叠加的值
            b1 = (a1 - c2);//保留a1的返回值
            a1 = (a1 - c2) * 1.24;//叠加魔化
            c1 = a1 - b1;//魔化叠加的值
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加战斗
            f1 = a1 - e1;//战斗叠加的值
            b = (a - c1);//保留a的返回值
            a = (a - c1) * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 25) {
            if (a >= h) {
                break;
            }
            d++;
            b4 = a4;//保留a4的返回值
            a4 = a4 * 1.24;//叠加魔化
            c4 = a4 - b4;//魔化叠加的值
            e4 = a4 - f4;//保留a4上一回合的值
            a4 = (a4 - f4) * 1.4;//叠加战斗
            f4 = a4 - e4;//战斗叠加的值
            b3 = (a3 - c4);//保留a3的返回值
            a3 = (a3 - c4) * 1.24;//叠加魔化
            c3 = a3 - b3;//魔化叠加的值
            e3 = a3 - f3;//保留a3上一回合的值
            a3 = (a3 - f3) * 1.4;//叠加战斗
            f3 = a3 - e3;//战斗叠加的值
            b2 = (a2 - c3);//保留a2的返回值
            a2 = (a2 - c3) * 1.24;//叠加魔化
            c2 = a2 - b2;//魔化叠加的值
            e2 = a2 - f2;//保留a2上一回合叠加的值
            a2 = (a2 - f2) * 1.4;//叠加战斗
            f2 = a2 - e2;//战斗叠加的值
            b1 = (a1 - c2);//保留a1的返回值
            a1 = (a1 - c2) * 1.24;//叠加魔化
            c1 = a1 - b1;//魔化叠加的值
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加战斗
            f1 = a1 - e1;//战斗叠加的值
            b = (a - c1);//保留a的返回值
            a = (a - c1) * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 30) {
            if (a >= h) {
                break;
            }
            d++;
            b5 = a5;//保留a5的返回值
            a5 = a5 * 1.24;//叠加魔化
            c5 = a5 - b5;//魔化叠加的值
            e5 = a5 - f5;//保留a5上一回合的值
            a5 = (a5 - f5) * 1.4;//叠加战斗
            f5 = a5 - e5;//战斗叠加的值
            b4 = (a4 - c5);//保留a4的返回值
            a4 = (a4 - c5) * 1.24;//叠加魔化
            c4 = a4 - b4;//魔化叠加的值
            e4 = a4 - f4;//保留a4上一回合的值
            a4 = (a4 - f4) * 1.4;//叠加战斗
            f4 = a4 - e4;//战斗叠加的值
            b3 = (a3 - c4);//保留a3的返回值
            a3 = (a3 - c4) * 1.24;//叠加魔化
            c3 = a3 - b3;//魔化叠加的值
            e3 = a3 - f3;//保留a3上一回合的值
            a3 = (a3 - f3) * 1.4;//叠加战斗
            f3 = a3 - e3;//战斗叠加的值
            b2 = (a2 - c3);//保留a2的返回值
            a2 = (a2 - c3) * 1.24;//叠加魔化
            c2 = a2 - b2;//魔化叠加的值
            e2 = a2 - f2;//保留a2上一回合的值
            a2 = (a2 - f2) * 1.4;//叠加战斗
            f2 = a2 - e2;//战斗叠加的值
            b1 = (a1 - c2);//保留a1的返回值
            a1 = (a1 - c2) * 1.24;//叠加魔化
            c1 = a1 - b1;//魔化叠加的值
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加魔化
            f1 = a1 - e1;//魔化叠加的值
            b = (a - c1);//保留a的返回值
            a = (a - c1) * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
    }

    public static void ZanDouMoHuaDieJia(double a) {
        double a1, a2, a3, a4, a5;
        double b = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0;
        double c = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0;
        double e = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0, e5 = 0;
        double f = 0, f1 = 0, f2 = 0, f3 = 0, f4 = 0, f5 = 0;
        double d = 0, h = 1000000, g;
        System.out.println("劈砍/穿刺值为:" + a);
        a1 = a2 = a3 = a4 = a5 = a;
        while (d < 5) {
            if (a >= h) {
                break;
            }
            d++;
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            b = a;//保留a的返回值
            a = a * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 10) {
            if (a >= h) {
                break;
            }
            d++;
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加战斗
            f1 = a1 - e1;//叠加战斗的值
            b1 = a1;//保留a的返回值
            a1 = a1 * 1.24;//叠加魔化
            c1 = a1 - b1;//魔化叠加的值
            g = f;//保留战斗叠加的值
            a = a - c1;//魔化的值消失
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            b = a;//保留a的返回值
            a = a * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 15) {
            if (a >= h) {
                break;
            }
            d++;
            e2 = a2 - f2;//保留a2上一回合的值
            a2 = (a2 - f2) * 1.4;//叠加战斗
            f2 = a2 - e2;//战斗叠加的值
            b2 = a2;//保留a2的返回值
            a2 = a2 * 1.24;//叠加魔化
            c2 = a2 - b2;//魔化叠加的值
            a1 = a1 - c2;//魔化的值消失
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加战斗
            f1 = a1 - e1;//战斗叠加的值
            b1 = a1;//保留a1的返回值
            a1 = a1 * 1.24;//叠加魔化
            c1 = a1 - b1;//叠加的值
            g = f;//保留战斗叠加的值
            a = a - c1;//魔化的值消失
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            b = a;//保留a的返回值
            a = a * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 20) {
            if (a >= h) {
                break;
            }
            d++;
            e3 = a3 - f3;//保留a3上一回合的值
            a3 = (a3 - f3) * 1.4;//叠加战斗
            f3 = a3 - e3;//战斗叠加的值
            b3 = a3;//保留a3的返回值
            a3 = a3 * 1.24;//叠加魔化
            c3 = a3 - b3;//魔化叠加的值
            a2 = a2 - c3;//魔化的值消失
            e2 = a2 - f2;//保留a2上一回合的值
            a2 = (a2 - f2) * 1.4;//叠加战斗
            f2 = a2 - e2;//战斗叠加的值
            b2 = a2;//保留a2的返回值
            a2 = a2 * 1.24;//叠加魔化
            c2 = a2 - b2;//魔化叠加的值
            a1 = a1 - c2;//魔化的值消失
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加战斗
            f1 = a1 - e1;//战斗叠加的值
            b1 = a1;//保留a1的返回值
            a1 = a1 * 1.24;//叠加魔化
            c1 = a1 - b1;//魔化叠加的值
            g = f;//保留战斗叠加的值
            a = a - c1;//魔化的值消失
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            b = a;//保留a的返回值
            a = a * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 25) {
            if (a >= h) {
                break;
            }
            d++;
            e4 = a4 - f4;//保留a4上一回合的值
            a4 = (a4 - f4) * 1.4;//叠加战斗
            f4 = a4 - e4;//战斗叠加的值
            b4 = a4;//保留a4的返回值
            a4 = a4 * 1.24;//叠加魔化
            c4 = a4 - b4;//魔化叠加的值
            a3 = a3 - c4;//魔化的值消失
            e3 = a3 - f3;//保留a3上一回合的值
            a3 = (a3 - f3) * 1.4;//叠加战斗
            f3 = a3 - e3;//战斗叠加的值
            b3 = a3;//保留a3的返回值
            a3 = a3 * 1.24;//叠加魔化
            c3 = a3 - b3;//魔化叠加的值
            a2 = a2 - c3;//魔化的值消失
            e2 = a2 - f2;//保留a2上一回合叠加的值
            a2 = (a2 - f2) * 1.4;//叠加战斗
            f2 = a2 - e2;//战斗叠加的值
            b2 = a2;//保留a2的返回值
            a2 = a2 * 1.24;//叠加魔化
            c2 = a2 - b2;//魔化叠加的值
            a1 = a1 - c2;//魔化的值消失
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加战斗
            f1 = a1 - e1;//战斗叠加的值
            b1 = a1;//保留a1的返回值
            a1 = a1 * 1.24;//叠加魔化
            c1 = a1 - b1;//魔化叠加的值
            a = a - c1;//魔化的值消失
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            b = a;//保留a的返回值
            a = a * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 30) {
            if (a >= h) {
                break;
            }
            d++;
            e5 = a5 - f5;//保留a5上一回合的值
            a5 = (a5 - f5) * 1.4;//叠加战斗
            f5 = a5 - e5;//战斗叠加的值
            b5 = a5;//保留a5的返回值
            a5 = a5 * 1.24;//叠加魔化
            c5 = a5 - b5;//魔化叠加的值
            a4 = a4 - c5;//魔化的值消失
            e4 = a4 - f4;//保留a4上一回合的值
            a4 = (a4 - f4) * 1.4;//叠加战斗
            f4 = a4 - e4;//战斗叠加的值
            b4 = a4;//保留a4的返回值
            a4 = a4 * 1.24;//叠加魔化
            c4 = a4 - b4;//魔化叠加的值
            a3 = a3 - c4;//魔化的值消失
            e3 = a3 - f3;//保留a3上一回合的值
            a3 = (a3 - f3) * 1.4;//叠加战斗
            f3 = a3 - e3;//战斗叠加的值
            b3 = a3;//保留a3的返回值
            a3 = a3 * 1.24;//叠加魔化
            c3 = a3 - b3;//魔化叠加的值
            a2 = a2 - c3;//魔化的值消失
            e2 = a2 - f2;//保留a2上一回合的值
            a2 = (a2 - f2) * 1.4;//叠加战斗
            f2 = a2 - e2;//战斗叠加的值
            b2 = a2;//保留a2的返回值
            a2 = a2 * 1.24;//叠加魔化
            c2 = a2 - b2;//魔化叠加的值
            a1 = a1 - c2;//魔化的值消失
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加魔化
            f1 = a1 - e1;//魔化叠加的值
            b1 = a1;//保留a1的返回值
            a1 = a1 * 1.24;//叠加魔化
            c1 = a1 - b1;//魔化叠加的值
            a = a - c1;//魔化的值消失
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            b = a;//保留a的返回值
            a = a * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
    }

    public static void HunMoHuaDanZanDouDieJia(double a) {
        double a1, a2, a3, a4, a5;//a的值
        double b = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0;
        //a的初值值保存
        double c = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0;
        //魔化叠加的值
        double e = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0, e5 = 0;
        //a的返回值保存
        double f = 0, f1 = 0, f2 = 0, f3 = 0, f4 = 0, f5 = 0;
        //战斗叠加的值
        double d = 0, h = 1000000, g, cp = 0, cp1 = 0;
        System.out.println("劈砍/穿刺值为:" + a);
        a1 = a2 = a3 = a4 = a5 = a;
        while (d < 5) {
            if (a >= h) {
                break;
            }
            d++;
            cp = 0;
            cp1 = 0;
            b = a;//保留a的返回值
            if (d % 2 != 0) {
                a = a * 1.24;//叠加魔化
                c = a - b;//魔化叠加的值
                cp = c;
                cp1 = c1;
            }
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            a = a > h ? h : a;//判断劈砍(穿吃值)
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 10) {
            if (a >= h) {
                break;
            }
            d++;
            cp = 0;
            cp1 = 0;
            b1 = a1;//保留a的返回值
            if (d % 2 != 0) {
                a1 = a1 * 1.24;//叠加魔化
                c1 = a1 - b1;//魔化叠加的值
            }
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加战斗
            f1 = a1 - e1;//叠加战斗的值
            b = (a - c1);//保留a的返回值
            if (d % 2 != 0) {
                a = (a - c1) * 1.24;//叠加魔化
                c = a - b;//魔化叠加的值
                cp = c;
                cp1 = c1;
            }
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            a = a > h ? h : a;
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 15) {
            if (a >= h) {
                break;
            }
            d++;
            cp = 0;
            cp1 = 0;
            b2 = a2;//保留a2的返回值
            if (d % 2 != 0) {
                a2 = a2 * 1.24;//叠加魔化
                c2 = a2 - b2;//魔化叠加的值
            }
            e2 = a2 - f2;//保留a2上一回合的值
            a2 = (a2 - f2) * 1.4;//叠加战斗
            f2 = a2 - e2;//战斗叠加的值
            b1 = (a1 - c2);//保留a1的返回值
            if (d % 2 != 0) {
                a1 = (a1 - c2) * 1.24;//叠加魔化
                c1 = a1 - b1;//叠加的值
            }
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加战斗
            f1 = a1 - e1;//战斗叠加的值
            b = (a - c1);//保留a的返回值
            if (d % 2 != 0) {
                a = (a - c1) * 1.24;//叠加魔化
                c = a - b;//魔化叠加的值
                cp = c;
                cp1 = c1;
            }
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            a = a > h ? h : a;
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 20) {
            if (a >= h) {
                break;
            }
            d++;
            b3 = a3;//保留a3的返回值
            if (d % 2 != 0) {
                a3 = a3 * 1.24;//叠加魔化
                c3 = a3 - b3;//魔化叠加的值
            }
            e3 = a3 - f3;//保留a3上一回合的值
            a3 = (a3 - f3) * 1.4;//叠加战斗
            f3 = a3 - e3;//战斗叠加的值
            b2 = (a2 - c3);//保留a2的返回值
            if (d % 2 != 0) {
                a2 = (a2 - c3) * 1.24;//叠加魔化
                c2 = a2 - b2;//魔化叠加的值
            }
            e2 = a2 - f2;//保留a2上一回合的值
            a2 = (a2 - f2) * 1.4;//叠加战斗
            f2 = a2 - e2;//战斗叠加的值
            b1 = (a1 - c2);//保留a1的返回值
            if (d % 2 != 0) {
                a1 = (a1 - c2) * 1.24;//叠加魔化
                c1 = a1 - b1;//魔化叠加的值
            }
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加战斗
            f1 = a1 - e1;//战斗叠加的值
            b = (a - c1);//保留a的返回值
            if (d % 2 != 0) {
                a = (a - c1) * 1.24;//叠加魔化
                c = a - b;//魔化叠加的值
                cp = c;
                cp1 = c1;
            }
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            a = a > h ? h : a;
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 25) {
            if (a >= h) {
                break;
            }
            d++;
            cp = 0;
            cp1 = 0;
            b4 = a4;//保留a4的返回值
            if (d % 2 != 0) {
                a4 = a4 * 1.24;//叠加魔化
                c4 = a4 - b4;//魔化叠加的值
            }
            e4 = a4 - f4;//保留a4上一回合的值
            a4 = (a4 - f4) * 1.4;//叠加战斗
            f4 = a4 - e4;//战斗叠加的值
            b3 = (a3 - c4);//保留a3的返回值
            if (d % 2 != 0) {
                a3 = (a3 - c4) * 1.24;//叠加魔化
                c3 = a3 - b3;//魔化叠加的值
            }
            e3 = a3 - f3;//保留a3上一回合的值
            a3 = (a3 - f3) * 1.4;//叠加战斗
            f3 = a3 - e3;//战斗叠加的值
            b2 = (a2 - c3);//保留a2的返回值
            if (d % 2 != 0) {
                a2 = (a2 - c3) * 1.24;//叠加魔化
                c2 = a2 - b2;//魔化叠加的值
            }
            e2 = a2 - f2;//保留a2上一回合叠加的值
            a2 = (a2 - f2) * 1.4;//叠加战斗
            f2 = a2 - e2;//战斗叠加的值
            b1 = (a1 - c2);//保留a1的返回值
            if (d % 2 != 0) {
                a1 = (a1 - c2) * 1.24;//叠加魔化
                c1 = a1 - b1;//魔化叠加的值
            }
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加战斗
            f1 = a1 - e1;//战斗叠加的值
            b = (a - c1);//保留a的返回值
            if (d % 2 != 0) {
                a = (a - c1) * 1.24;//叠加魔化
                c = a - b;//魔化叠加的值
                cp = c;
                cp1 = c1;
            }
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            a = a > h ? h : a;
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 30) {
            if (a >= h) {
                break;
            }
            d++;
            cp = 0;
            cp1 = 0;
            b5 = a5;//保留a5的返回值
            if (d % 2 != 0) {
                a5 = a5 * 1.24;//叠加魔化
                c5 = a5 - b5;//魔化叠加的值
            }
            e5 = a5 - f5;//保留a5上一回合的值
            a5 = (a5 - f5) * 1.4;//叠加战斗
            f5 = a5 - e5;//战斗叠加的值
            b4 = (a4 - c5);//保留a4的返回值
            if (d % 2 != 0) {
                a4 = (a4 - c5) * 1.24;//叠加魔化
                c4 = a4 - b4;//魔化叠加的值
            }
            e4 = a4 - f4;//保留a4上一回合的值
            a4 = (a4 - f4) * 1.4;//叠加战斗
            f4 = a4 - e4;//战斗叠加的值
            b3 = (a3 - c4);//保留a3的返回值
            if (d % 2 != 0) {
                a3 = (a3 - c4) * 1.24;//叠加魔化
                c3 = a3 - b3;//魔化叠加的值
            }
            e3 = a3 - f3;//保留a3上一回合的值
            a3 = (a3 - f3) * 1.4;//叠加战斗
            f3 = a3 - e3;//战斗叠加的值
            b2 = (a2 - c3);//保留a2的返回值
            if (d % 2 != 0) {
                a2 = (a2 - c3) * 1.24;//叠加魔化
                c2 = a2 - b2;//魔化叠加的值
            }
            e2 = a2 - f2;//保留a2上一回合的值
            a2 = (a2 - f2) * 1.4;//叠加战斗
            f2 = a2 - e2;//战斗叠加的值
            b1 = (a1 - c2);//保留a1的返回值
            if (d % 2 != 0) {
                a1 = (a1 - c2) * 1.24;//叠加魔化
                c1 = a1 - b1;//魔化叠加的值
            }
            e1 = a1 - f1;//保留a1上一回合的值
            a1 = (a1 - f1) * 1.4;//叠加战斗
            f1 = a1 - e1;//魔化叠加的值
            b = (a - c1);//保留a的返回值
            if (d % 2 != 0) {
                a = (a - c1) * 1.24;//叠加魔化
                c = a - b;//魔化叠加的值
                cp = c;
                cp1 = c1;
            }
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            a = (a - f) * 1.4;//叠加战斗
            f = a - e;//战斗叠加的值
            a = a > h ? h : a;
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
    }

    public static void DanMoHuaHunZanDouDieJia(double a) {
        double a1, a2, a3, a4, a5;//a的值
        double b = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0;
        //a的初值值保存
        double c = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0;
        //魔化叠加的值
        double e = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0, e5 = 0;
        //a的返回值保存
        double f = 0, f1 = 0, f2 = 0, f3 = 0, f4 = 0, f5 = 0;
        //战斗叠加的值
        double d = 0, h = 1000000, g, ch = 0, ch1 = 0;
        System.out.println("劈砍/穿刺值为:" + a);
        a1 = a2 = a3 = a4 = a5 = a;
        while (d < 5) {
            if (a >= h) {
                break;
            }
            d++;
            ch = 0;
            ch1 = 0;
            b = a;//保留a的返回值
            a = a * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            if (d % 2 == 0) {
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
                ch = f;
                ch1 = g;
            }
            a = a > h ? h : a;//判断劈砍(穿吃值)
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 10) {
            if (a >= h) {
                break;
            }
            d++;
            ch = 0;
            ch1 = 0;
            b1 = a1;//保留a的返回值
            a1 = a1 * 1.24;//叠加魔化
            c1 = a1 - b1;//魔化叠加的值
            e1 = a1 - f1;//保留a1上一回合的值
            if (d % 2 == 0) {
                a1 = (a1 - f1) * 1.4;//叠加战斗
                f1 = a1 - e1;//叠加战斗的值
            }
            b = (a - c1);//保留a的返回值
            a = (a - c1) * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            if (d % 2 == 0) {
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
                ch = f;
                ch1 = g;
            }
            a = a > h ? h : a;
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 15) {
            if (a >= h) {
                break;
            }
            d++;
            ch = 0;
            ch1 = 0;
            b2 = a2;//保留a2的返回值
            a2 = a2 * 1.24;//叠加魔化
            c2 = a2 - b2;//魔化叠加的值
            e2 = a2 - f2;//保留a2上一回合的值
            if (d % 2 == 0) {
                a2 = (a2 - f2) * 1.4;//叠加战斗
                f2 = a2 - e2;//战斗叠加的值
            }
            b1 = (a1 - c2);//保留a1的返回值
            a1 = (a1 - c2) * 1.24;//叠加魔化
            c1 = a1 - b1;//叠加的值
            e1 = a1 - f1;//保留a1上一回合的值
            if (d % 2 == 0) {
                a1 = (a1 - f1) * 1.4;//叠加战斗
                f1 = a1 - e1;//战斗叠加的值
            }
            b = (a - c1);//保留a的返回值
            a = (a - c1) * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            if (d % 2 == 0) {
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
                ch = f;
                ch1 = g;
            }
            a = a > h ? h : a;
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 20) {
            if (a >= h) {
                break;
            }
            d++;
            ch = 0;
            ch1 = 0;
            b3 = a3;//保留a3的返回值
            a3 = a3 * 1.24;//叠加魔化
            c3 = a3 - b3;//魔化叠加的值
            e3 = a3 - f3;//保留a3上一回合的值
            if (d % 2 == 0) {
                a3 = (a3 - f3) * 1.4;//叠加战斗
                f3 = a3 - e3;//战斗叠加的值
            }
            b2 = (a2 - c3);//保留a2的返回值
            a2 = (a2 - c3) * 1.24;//叠加魔化
            c2 = a2 - b2;//魔化叠加的值
            e2 = a2 - f2;//保留a2上一回合的值
            if (d % 2 == 0) {
                a2 = (a2 - f2) * 1.4;//叠加战斗
                f2 = a2 - e2;//战斗叠加的值
            }
            b1 = (a1 - c2);//保留a1的返回值
            a1 = (a1 - c2) * 1.24;//叠加魔化
            c1 = a1 - b1;//魔化叠加的值
            e1 = a1 - f1;//保留a1上一回合的值
            if (d % 2 == 0) {
                a1 = (a1 - f1) * 1.4;//叠加战斗
                f1 = a1 - e1;//战斗叠加的值
            }
            b = (a - c1);//保留a的返回值
            a = (a - c1) * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            if (d % 2 == 0) {
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
                ch = f;
                ch1 = g;
            }
            a = a > h ? h : a;
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 25) {
            if (a >= h) {
                break;
            }
            d++;
            ch = 0;
            ch1 = 0;
            b4 = a4;//保留a4的返回值
            a4 = a4 * 1.24;//叠加魔化
            c4 = a4 - b4;//魔化叠加的值
            e4 = a4 - f4;//保留a4上一回合的值
            if (d % 2 == 0) {
                a4 = (a4 - f4) * 1.4;//叠加战斗
                f4 = a4 - e4;//战斗叠加的值
            }
            b3 = (a3 - c4);//保留a3的返回值
            a3 = (a3 - c4) * 1.24;//叠加魔化
            c3 = a3 - b3;//魔化叠加的值
            e3 = a3 - f3;//保留a3上一回合的值
            if (d % 2 == 0) {
                a3 = (a3 - f3) * 1.4;//叠加战斗
                f3 = a3 - e3;//战斗叠加的值
            }
            b2 = (a2 - c3);//保留a2的返回值
            a2 = (a2 - c3) * 1.24;//叠加魔化
            c2 = a2 - b2;//魔化叠加的值
            e2 = a2 - f2;//保留a2上一回合叠加的值
            if (d % 2 == 0) {
                a2 = (a2 - f2) * 1.4;//叠加战斗
                f2 = a2 - e2;//战斗叠加的值
            }
            b1 = (a1 - c2);//保留a1的返回值
            a1 = (a1 - c2) * 1.24;//叠加魔化
            c1 = a1 - b1;//魔化叠加的值
            e1 = a1 - f1;//保留a1上一回合的值
            if (d % 2 == 0) {
                a1 = (a1 - f1) * 1.4;//叠加战斗
                f1 = a1 - e1;//战斗叠加的值
            }
            b = (a - c1);//保留a的返回值
            a = (a - c1) * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            if (d % 2 == 0) {
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
                ch = f;
                ch1 = g;
            }
            a = a > h ? h : a;
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
        while (d < 30) {
            if (a >= h) {
                break;
            }
            d++;
            ch = 0;
            ch1 = 0;
            b5 = a5;//保留a5的返回值
            a5 = a5 * 1.24;//叠加魔化
            c5 = a5 - b5;//魔化叠加的值
            e5 = a5 - f5;//保留a5上一回合的值
            if (d % 2 == 0) {
                a5 = (a5 - f5) * 1.4;//叠加战斗
                f5 = a5 - e5;//战斗叠加的值
            }
            b4 = (a4 - c5);//保留a4的返回值
            a4 = (a4 - c5) * 1.24;//叠加魔化
            c4 = a4 - b4;//魔化叠加的值
            e4 = a4 - f4;//保留a4上一回合的值
            if (d % 2 == 0) {
                a4 = (a4 - f4) * 1.4;//叠加战斗
                f4 = a4 - e4;//战斗叠加的值
            }
            b3 = (a3 - c4);//保留a3的返回值
            a3 = (a3 - c4) * 1.24;//叠加魔化
            c3 = a3 - b3;//魔化叠加的值
            e3 = a3 - f3;//保留a3上一回合的值
            if (d % 2 == 0) {
                a3 = (a3 - f3) * 1.4;//叠加战斗
                f3 = a3 - e3;//战斗叠加的值
            }
            b2 = (a2 - c3);//保留a2的返回值
            a2 = (a2 - c3) * 1.24;//叠加魔化
            c2 = a2 - b2;//魔化叠加的值
            e2 = a2 - f2;//保留a2上一回合的值
            if (d % 2 == 0) {
                a2 = (a2 - f2) * 1.4;//叠加战斗
                f2 = a2 - e2;//战斗叠加的值
            }
            b1 = (a1 - c2);//保留a1的返回值
            a1 = (a1 - c2) * 1.24;//叠加魔化
            c1 = a1 - b1;//魔化叠加的值
            e1 = a1 - f1;//保留a1上一回合的值
            if (d % 2 == 0) {
                a1 = (a1 - f1) * 1.4;//叠加战斗
                f1 = a1 - e1;//魔化叠加的值
            }
            b = (a - c1);//保留a的返回值
            a = (a - c1) * 1.24;//叠加魔化
            c = a - b;//魔化叠加的值
            g = f;//保留战斗叠加的值
            e = a - f;//保留a上一回合的值
            if (d % 2 == 0) {
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
                ch = f;
                ch1 = g;
            }
            a = a > h ? h : a;
            MoHuaZhanDouGongJuBao(d, a, c, f, g, c1);
        }
    }

    /**
     * @author LJ    2021/1/11
     * 产生Min~Max的范围随机数，包含Min和Max两个数在内
     */
    //最高武商不能低于最低武商
    public static int fixedRange(int Min, int Max) {
        try {
            if (Max <= Min) {
                throw new Exception("输入的范围无效！");
            }
        } catch (Exception e) {
            System.out.println("请检查输入的范围第一个数字是否比第二个小！");
            System.out.println("感谢您的使用，等您想好了欢迎您的再次使用");
            System.exit(1);
        }
        return (int) Math.round(Math.random() * (Max - Min) + Min);
    }

    //随机生成武商的平均值
    public static int WuShangJunZhi(int z, int a, int b) {
        //输入攻次后循环生成武商，以求得最准确的武商均值
        int sum = 0;
        for (int i = 0; i < z; i++) {
            int abc = fixedRange(a, b);
            sum += abc;
        }
        return sum / z;
    }

    //随机生产隔档
    public static int GedangShengCheng(int z) {
        int kkk = z < 7 ? z : 7;
        Random hh = new Random();
        int qq = hh.nextInt(kkk + 1);
        return qq;
    }

    //打副本回合模拟
    //打副本模拟输出工具
    public static void DaFuBenMoNiGongju(int b, int z, double a, double m, double o1, double o2, double o3, double y
            , double o4, double o5, double o6, double x, double x1, double r, double y1, int k1, int k2, int k3
            , int k4, int k5, int k6) {
        System.out.printf("【当前的回合%d】\n", b);
        System.out.printf("当前的攻次:%d\n", z);
        System.out.printf("当前的劈砍(穿刺)值%.0f\n", a);

        if (o1 <= 0) {
            if (k1 == 1) {
                System.out.printf("全减免疫伤害(魔攻无效):%.0f\n", m);
            }
            System.out.printf("全减免疫(魔攻无效)伤害任务已完成\n");
        } else {
            System.out.printf("全减免疫伤害(魔攻无效):%.0f\n", m);
            System.out.printf("全减免疫(魔攻无效)剩余生命:%.0f\n\n", o1);
        }

        if (o2 <= 0) {
            if (k2 == 1) {
                System.out.printf("全减免疫魔免伤害(强命):%.2f\n", y);
            }
            System.out.printf("全减免疫魔免(强命)伤害任务已完成\n");
        } else {
            System.out.printf("全减免疫魔免伤害(强命):%.2f\n", y);
            System.out.printf("全减免疫魔免(强命)剩余生命:%.0f\n\n", o2);
        }

        if (o3 <= 0) {
            if (k3 == 1) {
                System.out.printf("全减免疫魔免最低伤害:%.0f\n", x);
            }
            System.out.printf("全减免疫魔免最低伤害任务已完成\n");
        } else {
            System.out.printf("全减免疫魔免最低伤害:%.0f\n", x);
            System.out.printf("全减免疫魔免最低伤害剩余生命:%.0f\n\n", o3);
        }

        if (o4 <= 0) {
            if (k4 == 1) {
                System.out.printf("全减免疫伤害(魔攻有效):%.0f\n", r);
            }
            System.out.printf("全减免疫伤害(魔攻有效)任务已完成\n");
        } else {
            System.out.printf("全减免疫伤害(魔攻有效):%.0f\n", r);
            System.out.printf("全减免疫伤害(魔攻有效)剩余生命:%.0f\n\n", o4);
        }

        if (o5 <= 0) {
            if (k5 == 1) {
                System.out.printf("全减魔攻有效伤害(强命):%.2f\n", y1);
            }
            System.out.printf("全减魔攻有效伤害(强命)任务已完成\n");
        } else {
            System.out.printf("全减魔攻有效伤害(强命):%.2f\n", y1);
            System.out.printf("全减魔攻有效伤害(强命)剩余生命:%.0f\n\n", o5);
        }

        if (o6 <= 0) {
            if (k6 == 1) {
                System.out.printf("全减魔攻有效最低伤害:%.0f\n", x1);
            }
            System.out.printf("全减魔攻有效最低伤害任务已完成\n\n");
        } else {
            System.out.printf("全减魔攻有效最低伤害:%.0f\n", x1);
            System.out.printf("全减魔攻有效最低伤害剩余生命:%.0f\n", o6);
        }

    }

    //打副本回合純净
    public static void DaFuBenMoNiCunJing(int b, int z, double a, double m, double o1, int k1) {
        System.out.printf("【当前的回合%d】\n", b);
        System.out.printf("当前的攻次:%d\n", z);
        System.out.printf("当前的劈砍(穿刺)值%.0f\n", a);
        if (o1 <= 0) {
            if (k1 == 1) {
                System.out.printf("全减免疫伤害(魔攻无效):%.0f\n", m);
            }
            System.out.printf("全减免疫(魔攻无效)伤害任务已完成\n");
        } else {
            System.out.printf("全减免疫伤害(魔攻无效):%.0f\n", m);
            System.out.printf("全减免疫(魔攻无效)剩余生命:%.0f\n\n", o1);
        }
    }

    //单魔化打副本回合
    public static void DanMoHuaDaFuBen(int i, int j, int z, int v, int o, double qm, double a, int xz2) {
        //i,j最高最低武商     z攻次     v技能攻次      o怪物总血量      qm强命     a武商劈砍值
        double a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0;
        //叠加魔化(a后面的值为返回的伦数)
        double d1 = 0, d2 = 0, d3 = 0, d4 = 0, d5 = 0;
        //返回值(b后面得值为返回的伦数)
        double c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0;
        //叠加得值(c后面得值为返回的伦数)
        int h = 1000000, b = 0;
        double k, l = 0, m = 0, r = 0;
        //对应怪物所剩血量
        double o1 = 0, o2 = 0, o3 = 0, o4 = 0, o5 = 0, o6 = 0;
        //完成结束语只会出现在第一次
        int k1 = 1, k2 = 1, k3 = 1, k4 = 1, k5 = 1, k6 = 1;
        //魔攻有效/无效最低伤害
        double x = 0, x1 = 0;
        double y = 0, y1 = 0;//强命伤害
        //动态生成武商，伤害浮动更加真实
        k = WuShangJunZhi(z, i, j);
        qm = qm > 30 ? qm : 30;
        qm = qm < 100 ? qm : 100;
        qm = qm / 100;
        z = z + v;
        a1 = a2 = a3 = a4 = a5 = a;
        o1 = o2 = o3 = o4 = o5 = o6 = o;
        while (b < 5) {
            if (xz2 == 1) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            //魔化持续5回合
            if (a < h) {
                a = a * 1.24;//叠魔化得值
            }
            a = a > h ? h : a;//判断劈砍(穿刺值)
            z = z + 6;//攻次叠加
            z = z > 99 ? 99 : z;//判断攻次
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 1) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 4) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 10) {
            if (xz2 == 1) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                d1 = a1;//保存e的返回值(第一轮顶得值)
                a1 = a1 * 1.24;//魔化叠加(第一轮顶得值)
                c1 = a1 - d1;//叠加的值(第一轮顶得值)
                a = (a - c1) * 1.24;//魔化叠加
            }
            a = a > h ? h : a;//判断劈砍(穿刺值)
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 1) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 4) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 15) {
            if (xz2 == 1) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                d2 = a2;//保留a2的返回值(第二轮顶得值)
                a2 = a2 * 1.24;//魔化叠加(第二轮顶得值)
                c2 = a2 - d2;//叠加的值(第二轮顶的值)
                d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
                a1 = (a1 - c2) * 1.24;//魔化叠加(第一轮轮顶得值)
                c1 = a1 - d1;//叠加的值(第一轮顶的值)
                a = (a - c1) * 1.24;//魔化叠加
            }
            a = a > h ? h : a;//判断劈砍(穿刺值)
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 1) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 4) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 20) {
            if (xz2 == 1) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                d3 = a3;//保留a3的返回值(第三轮顶的值)
                a3 = a3 * 1.24;//魔化叠加(第三轮顶的值)
                c3 = a3 - d3;//顶得值(第三轮顶的值)
                d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
                a2 = (a2 - c3) * 1.24;//魔化叠加(第二轮顶得值)
                c2 = a2 - d2;//叠加的值(第二轮顶的值)
                d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
                a1 = (a1 - c2) * 1.24;//魔化叠加(第一轮轮顶得值)
                c1 = a1 - d1;//叠加的值(第一轮顶的值)
                a = (a - c1) * 1.24;//魔化叠加
            }
            a = a > h ? h : a;//判断劈砍(穿刺值)
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 1) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 4) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 25) {
            if (xz2 == 1) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                d4 = a4;//保留a4的返回值(第四轮顶的值)
                a4 = a4 * 1.24;//魔化叠加的值(第四轮顶的值)
                c4 = a4 - d4;//顶的值(第四轮顶的值)
                d3 = a3 - c4;//保留a3的返回值(第三轮顶的值)
                a3 = (a3 - c4) * 1.24;//魔化叠加(第三轮顶的值)
                c3 = a3 - d3;//顶得值(第三轮顶的值)
                d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
                a2 = (a2 - c3) * 1.24;//魔化叠加(第二轮顶得值)
                c2 = a2 - d2;//叠加的值(第二轮顶的值)
                d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
                a1 = (a1 - c2) * 1.24;//魔化叠加(第一轮轮顶得值)
                c1 = a1 - d1;//叠加的值(第一轮顶的值)
                a = (a - c1) * 1.24;//魔化叠加
            }
            a = a > h ? h : a;//判断劈砍(穿刺值)
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 1) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 4) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 30) {
            if (xz2 == 1) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            {
                d5 = a5;//保留a5的返回值(第五轮顶的值)
                a5 = a5 * 1.24;//魔化叠加的值(第五轮顶的值)
                c5 = a5 - d5;//顶的值(第五轮顶的值)
                d4 = a4 - c5;//保留a4的返回值(第四轮顶的值)
                a4 = (a4 - c5) * 1.24;//魔化叠加的值(第四轮顶的值)
                c4 = a4 - d4;//顶的值(第四轮顶的值)
                d3 = a3 - c4;//保留a3的返回值(第三轮顶的值)
                a3 = (a3 - c4) * 1.24;//魔化叠加(第三轮顶的值)
                c3 = a3 - d3;//顶得值(第三轮顶的值)
                d2 = a2 - c3;//保留a2的返回值(第二轮顶得值)
                a2 = (a2 - c3) * 1.24;//魔化叠加(第二轮顶得值)
                c2 = a2 - d2;//叠加的值(第二轮顶的值)
                d1 = a1 - c2;//保存a1的返回值(第一轮顶得值)
                a1 = (a1 - c2) * 1.24;//魔化叠加(第一轮轮顶得值)
                c1 = a1 - d1;//叠加的值(第一轮顶的值)
                a = (a - c1) * 1.24;//魔化叠加
            }
            a = a > h ? h : a;//判断劈砍(穿刺值)
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 1) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 4) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
    }

    //魔化战斗打副本回合
    public static void MoHuaZhanDouDaFuBen(int i, int j, int z, int v, int o, double qm, double a, int xz2) {
        //i,j最高最低武商     z攻次     v技能攻次      o怪物总血量      qm强命     a武商劈砍值
        double a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0;

        double d1 = 0, d2 = 0, d3 = 0, d4 = 0, d5 = 0;

        double c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0;

        int h = 1000000, b = 0;
        double k, l = 0, m = 0, r = 0;
        //对应怪物所剩血量
        double o1 = 0, o2 = 0, o3 = 0, o4 = 0, o5 = 0, o6 = 0;
        //完成结束语只会出现在第一次
        int k1 = 1, k2 = 1, k3 = 1, k4 = 1, k5 = 1, k6 = 1;
        //魔攻有效/无效最低伤害
        double x = 0, x1 = 0;
        double y = 0, y1 = 0;//强命伤害
        //战斗叠加的值
        double f = 0, f1 = 0, f2 = 0, f3 = 0, f4 = 0, f5 = 0;
        double e = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0, e5 = 0;
        //动态生成武商，伤害浮动更加真实
        k = WuShangJunZhi(z, i, j);
        qm = qm > 30 ? qm : 30;
        qm = qm < 100 ? qm : 100;
        qm = qm / 100;
        z = z + v;
        //保存a的初值
        a1 = a2 = a3 = a4 = a5 = a;
        o1 = o2 = o3 = o4 = o5 = o6 = o;

        while (b < 5) {
            if (xz2 == 2) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                a = a * 1.24;//叠加魔化
                e = a - f;//保留a上一回合的值
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
            }
            a = a > h ? h : a;//判断劈砍(穿吃值)
            z = z + 6;//攻次叠加
            z = z > 99 ? 99 : z;//判断攻次
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 2) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 5) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 10) {
            if (xz2 == 2) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                d1 = a1;//保留a的返回值
                a1 = a1 * 1.24;//叠加魔化
                c1 = a1 - d1;//魔化叠加的值
                e1 = a1 - f1;//保留a1上一回合的值
                a1 = (a1 - f1) * 1.4;//叠加魔化
                f1 = a1 - e1;//叠加魔化的值
                a = (a - c1) * 1.24;//叠加魔化
                e = a - f;//保留a上一回合的值
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
            }
            a = a > h ? h : a;
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 2) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 5) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 15) {
            if (xz2 == 2) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                d2 = a2;//保留a2的返回值
                a2 = a2 * 1.24;//叠加魔化
                c2 = a2 - d2;//魔化叠加的值
                e2 = a2 - f2;//保留a2上一回合的值
                a2 = (a2 - f2) * 1.4;//叠加战斗
                f2 = a2 - e2;//战斗叠加的值
                d1 = (a1 - c2);//保留a1的返回值
                a1 = (a1 - c2) * 1.24;//叠加魔化
                c1 = a1 - d1;//叠加的值
                e1 = a1 - f1;//保留a1上一回合的值
                a1 = (a1 - f1) * 1.4;//叠加战斗
                f1 = a1 - e1;//战斗叠加的值
                a = (a - c1) * 1.24;//叠加魔化
                e = a - f;//保留a上一回合的值
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
            }
            a = a > h ? h : a;
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 2) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 5) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 20) {
            if (xz2 == 2) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                d3 = a3;//保留a3的返回值
                a3 = a3 * 1.24;//叠加魔化
                c3 = a3 - d3;//魔化叠加的值
                e3 = a3 - f3;//保留a3上一回合的值
                a3 = (a3 - f3) * 1.4;//叠加战斗
                f3 = a3 - e3;//战斗叠加的值
                d2 = (a2 - c3);//保留a2的返回值
                a2 = (a2 - c3) * 1.24;//叠加魔化
                c2 = a2 - d2;//魔化叠加的值
                e2 = a2 - f2;//保留a2上一回合的值
                a2 = (a2 - f2) * 1.4;//叠加战斗
                f2 = a2 - e2;//战斗叠加的值
                d1 = (a1 - c2);//保留a1的返回值
                a1 = (a1 - c2) * 1.24;//叠加魔化
                c1 = a1 - d1;//魔化叠加的值
                e1 = a1 - f1;//保留a1上一回合的值
                a1 = (a1 - f1) * 1.4;//叠加战斗
                f1 = a1 - e1;//战斗叠加的值
                a = (a - c1) * 1.24;//叠加魔化
                e = a - f;//保留a上一回合的值
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
            }
            a = a > h ? h : a;
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 2) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 5) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 25) {
            if (xz2 == 2) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                d4 = a4;//保留a4的返回值
                a4 = a4 * 1.24;//叠加魔化
                c4 = a4 - d4;//魔化叠加的值
                e4 = a4 - f4;//保留a4上一回合的值
                a4 = (a4 - f4) * 1.4;//叠加战斗
                f4 = a4 - e4;//战斗叠加的值
                d3 = (a3 - c4);//保留a3的返回值
                a3 = (a3 - c4) * 1.24;//叠加魔化
                c3 = a3 - d3;//魔化叠加的值
                e3 = a3 - f3;//保留a3上一回合的值
                a3 = (a3 - f3) * 1.4;//叠加战斗
                f3 = a3 - e3;//战斗叠加的值
                d2 = (a2 - c3);//保留a2的返回值
                a2 = (a2 - c3) * 1.24;//叠加魔化
                c2 = a2 - d2;//魔化叠加的值
                e2 = a2 - f2;//保留a2上一回合叠加的值
                a2 = (a2 - f2) * 1.4;//叠加战斗
                f2 = a2 - e2;//战斗叠加的值
                d1 = (a1 - c2);//保留a1的返回值
                a1 = (a1 - c2) * 1.24;//叠加魔化
                c1 = a1 - d1;//魔化叠加的值
                e1 = a1 - f1;//保留a1上一回合的值
                a1 = (a1 - f1) * 1.4;//叠加战斗
                f1 = a1 - e1;//战斗叠加的值
                a = (a - c1) * 1.24;//叠加魔化
                e = a - f;//保留a上一回合的值
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
            }
            a = a > h ? h : a;
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 2) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 5) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 30) {
            if (xz2 == 2) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                d5 = a5;//保留a5的返回值
                a5 = a5 * 1.24;//叠加魔化
                c5 = a5 - d5;//魔化叠加的值
                e5 = a5 - f5;//保留a5上一回合的值
                a5 = (a5 - f5) * 1.4;//叠加战斗
                f5 = a5 - e5;//战斗叠加的值
                d4 = (a4 - c5);//保留a4的返回值
                a4 = (a4 - c5) * 1.24;//叠加魔化
                c4 = a4 - d4;//魔化叠加的值
                e4 = a4 - f4;//保留a4上一回合的值
                a4 = (a4 - f4) * 1.4;//叠加战斗
                f4 = a4 - e4;//战斗叠加的值
                d3 = (a3 - c4);//保留a3的返回值
                a3 = (a3 - c4) * 1.24;//叠加魔化
                c3 = a3 - d3;//魔化叠加的值
                e3 = a3 - f3;//保留a3上一回合的值
                a3 = (a3 - f3) * 1.4;//叠加战斗
                f3 = a3 - e3;//战斗叠加的值
                d2 = (a2 - c3);//保留a2的返回值
                a2 = (a2 - c3) * 1.24;//叠加魔化
                c2 = a2 - d2;//魔化叠加的值
                e2 = a2 - f2;//保留a2上一回合的值
                a2 = (a2 - f2) * 1.4;//叠加战斗
                f2 = a2 - e2;//战斗叠加的值
                d1 = (a1 - c2);//保留a1的返回值
                a1 = (a1 - c2) * 1.24;//叠加魔化
                c1 = a1 - d1;//魔化叠加的值
                e1 = a1 - f1;//保留a1上一回合的值
                a1 = (a1 - f1) * 1.4;//叠加魔化
                f1 = a1 - e1;//魔化叠加的值
                a = (a - c1) * 1.24;//叠加魔化
                e = a - f;//保留a上一回合的值
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
            }
            a = a > h ? h : a;
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 2) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 5) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
    }

    //战斗魔化打副本回合
    public static void ZhanDouMoHuaDaFuBen(int i, int j, int z, int v, int o, double qm, double a, int xz2) {
        //i,j最高最低武商     z攻次     v技能攻次      o怪物总血量      qm强命     a武商劈砍值
        double a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0;

        double d1 = 0, d2 = 0, d3 = 0, d4 = 0, d5 = 0;

        double c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0;

        int h = 1000000, b = 0;
        double k, l = 0, m = 0, r = 0;
        //对应怪物所剩血量
        double o1 = 0, o2 = 0, o3 = 0, o4 = 0, o5 = 0, o6 = 0;
        //完成结束语只会出现在第一次
        int k1 = 1, k2 = 1, k3 = 1, k4 = 1, k5 = 1, k6 = 1;
        //魔攻有效/无效最低伤害
        double x = 0, x1 = 0;
        double y = 0, y1 = 0;//强命伤害
        //战斗叠加的值
        double f = 0, f1 = 0, f2 = 0, f3 = 0, f4 = 0, f5 = 0;
        double e = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0, e5 = 0;
        //动态生成武商，伤害浮动更加真实
        k = WuShangJunZhi(z, i, j);
        qm = qm > 30 ? qm : 30;
        qm = qm < 100 ? qm : 100;
        qm = qm / 100;
        z = z + v;
        //保存a的初值
        a1 = a2 = a3 = a4 = a5 = a;
        o1 = o2 = o3 = o4 = o5 = o6 = o;

        while (b < 5) {
            if (xz2 == 3) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                e = a - f;//保留a上一回合的值
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
                a = a * 1.24;//叠加魔化
            }
            a = a > h ? h : a;//判断劈砍(穿刺值)
            z = z + 6;//攻次叠加
            z = z > 99 ? 99 : z;//判断攻次
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 3) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 6) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 10) {
            if (xz2 == 3) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                e1 = a1 - f1;//保留a1上一回合的值
                a1 = (a1 - f1) * 1.4;//叠加战斗
                f1 = a1 - e1;//叠加战斗的值
                d1 = a1;//保留a的返回值
                a1 = a1 * 1.24;//叠加魔化
                c1 = a1 - d1;//魔化叠加的值
                a = a - c1;//魔化的值消失
                e = a - f;//保留a上一回合的值
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
                a = a * 1.24;//叠加魔化
            }
            a = a > h ? h : a;//判断劈砍(穿刺值)
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 3) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 6) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 15) {
            if (xz2 == 3) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                e2 = a2 - f2;//保留a2上一回合的值
                a2 = (a2 - f2) * 1.4;//叠加战斗
                f2 = a2 - e2;//战斗叠加的值
                d2 = a2;//保留a2的返回值
                a2 = a2 * 1.24;//叠加魔化
                c2 = a2 - d2;//魔化叠加的值
                a1 = a1 - c2;//魔化的值消失
                e1 = a1 - f1;//保留a1上一回合的值
                a1 = (a1 - f1) * 1.4;//叠加战斗
                f1 = a1 - e1;//战斗叠加的值
                d1 = a1;//保留a1的返回值
                a1 = a1 * 1.24;//叠加魔化
                c1 = a1 - d1;//叠加的值
                a = a - c1;//魔化的值消失
                e = a - f;//保留a上一回合的值
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
                a = a * 1.24;//叠加魔化
            }
            a = a > h ? h : a;//判断劈砍(穿刺值)
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 3) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 6) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 20) {
            if (xz2 == 3) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                e3 = a3 - f3;//保留a3上一回合的值
                a3 = (a3 - f3) * 1.4;//叠加战斗
                f3 = a3 - e3;//战斗叠加的值
                d3 = a3;//保留a3的返回值
                a3 = a3 * 1.24;//叠加魔化
                c3 = a3 - d3;//魔化叠加的值
                a2 = a2 - c3;//魔化的值消失
                e2 = a2 - f2;//保留a2上一回合的值
                a2 = (a2 - f2) * 1.4;//叠加战斗
                f2 = a2 - e2;//战斗叠加的值
                d2 = a2;//保留a2的返回值
                a2 = a2 * 1.24;//叠加魔化
                c2 = a2 - d2;//魔化叠加的值
                a1 = a1 - c2;//魔化的值消失
                e1 = a1 - f1;//保留a1上一回合的值
                a1 = (a1 - f1) * 1.4;//叠加战斗
                f1 = a1 - e1;//战斗叠加的值
                d1 = a1;//保留a1的返回值
                a1 = a1 * 1.24;//叠加魔化
                c1 = a1 - d1;//魔化叠加的值
                a = a - c1;//魔化的值消失
                e = a - f;//保留a上一回合的值
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
                a = a * 1.24;//叠加魔化
            }
            a = a > h ? h : a;//判断劈砍(穿刺值)
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 3) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 6) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 25) {
            if (xz2 == 3) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }
            b++;//回合
            if (a < h) {
                e4 = a4 - f4;//保留a4上一回合的值
                a4 = (a4 - f4) * 1.4;//叠加战斗
                f4 = a4 - e4;//战斗叠加的值
                d4 = a4;//保留a4的返回值
                a4 = a4 * 1.24;//叠加魔化
                c4 = a4 - d4;//魔化叠加的值
                a3 = a3 - c4;//魔化的值消失
                e3 = a3 - f3;//保留a3上一回合的值
                a3 = (a3 - f3) * 1.4;//叠加战斗
                f3 = a3 - e3;//战斗叠加的值
                d3 = a3;//保留a3的返回值
                a3 = a3 * 1.24;//叠加魔化
                c3 = a3 - d3;//魔化叠加的值
                a2 = a2 - c3;//魔化的值消失
                e2 = a2 - f2;//保留a2上一回合叠加的值
                a2 = (a2 - f2) * 1.4;//叠加战斗
                f2 = a2 - e2;//战斗叠加的值
                d2 = a2;//保留a2的返回值
                a2 = a2 * 1.24;//叠加魔化
                c2 = a2 - d2;//魔化叠加的值
                a1 = a1 - c2;//魔化的值消失
                e1 = a1 - f1;//保留a1上一回合的值
                a1 = (a1 - f1) * 1.4;//叠加战斗
                f1 = a1 - e1;//战斗叠加的值
                d1 = a1;//保留a1的返回值
                a1 = a1 * 1.24;//叠加魔化
                c1 = a1 - d1;//魔化叠加的值
                a = a - c1;//魔化的值消失
                e = a - f;//保留a上一回合的值
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
                a = a * 1.24;//叠加魔化
            }
            a = a > h ? h : a;//判断劈砍(穿刺值)
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 3) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 6) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
        while (b < 30) {
            if (xz2 == 3) {
                if (o1 <= 0 && o2 <= 0 && o3 <= 0 && o4 <= 0 && o5 <= 0 && o6 <= 0) {
                    break;
                }
            } else {
                if (o1 <= 0) {
                    break;
                }
            }

            b++;//回合
            if (a < h) {
                e5 = a5 - f5;//保留a5上一回合的值
                a5 = (a5 - f5) * 1.4;//叠加战斗
                f5 = a5 - e5;//战斗叠加的值
                d5 = a5;//保留a5的返回值
                a5 = a5 * 1.24;//叠加魔化
                c5 = a5 - d5;//魔化叠加的值
                a4 = a4 - c5;//魔化的值消失
                e4 = a4 - f4;//保留a4上一回合的值
                a4 = (a4 - f4) * 1.4;//叠加战斗
                f4 = a4 - e4;//战斗叠加的值
                d4 = a4;//保留a4的返回值
                a4 = a4 * 1.24;//叠加魔化
                c4 = a4 - d4;//魔化叠加的值
                a3 = a3 - c4;//魔化的值消失
                e3 = a3 - f3;//保留a3上一回合的值
                a3 = (a3 - f3) * 1.4;//叠加战斗
                f3 = a3 - e3;//战斗叠加的值
                d3 = a3;//保留a3的返回值
                a3 = a3 * 1.24;//叠加魔化
                c3 = a3 - d3;//魔化叠加的值
                a2 = a2 - c3;//魔化的值消失
                e2 = a2 - f2;//保留a2上一回合的值
                a2 = (a2 - f2) * 1.4;//叠加战斗
                f2 = a2 - e2;//战斗叠加的值
                d2 = a2;//保留a2的返回值
                a2 = a2 * 1.24;//叠加魔化
                c2 = a2 - d2;//魔化叠加的值
                a1 = a1 - c2;//魔化的值消失
                e1 = a1 - f1;//保留a1上一回合的值
                a1 = (a1 - f1) * 1.4;//叠加魔化
                f1 = a1 - e1;//魔化叠加的值
                d1 = a1;//保留a1的返回值
                a1 = a1 * 1.24;//叠加魔化
                c1 = a1 - d1;//魔化叠加的值
                a = a - c1;//魔化的值消失
                e = a - f;//保留a上一回合的值
                a = (a - f) * 1.4;//叠加战斗
                f = a - e;//战斗叠加的值
                a = a * 1.24;//叠加魔化
            }
            a = a > h ? h : a;//判断劈砍(穿刺值)
            l = (k * z + a) * 1.5;//基础伤害值

            //全减免疫伤害(魔攻无效)
            m = l * 0.3 < o1 ? l * 0.3 : o1;
            o1 = o1 - m > 0 ? o1 - m : 0;

            if (xz2 == 3) {
                //全减免疫(魔攻无效)强命伤害
                y = l * 0.3 * qm < o2 ? l * 0.3 * qm : o2;
                o2 = o2 - y > 0 ? o2 - y : 0;

                //全减免疫(魔攻无效)最低伤害
                x = (k * (z - 7) + a) * 1.5 * 0.3 < o3 ? (k * (z - 7) + a) * 1.5 * 0.3 : o3;
                o3 = o3 - x > 0 ? o3 - x : 0;

                //全减免疫伤害(魔攻有效)
                r = l < o4 ? l : o4;
                o4 = o4 - r > 0 ? o4 - r : 0;

                //全减免疫(魔攻有效)强命伤害
                y1 = l * qm < o5 ? l * qm : o5;
                o5 = o5 - y1 > 0 ? o5 - y1 : 0;

                //全减免疫(魔攻有效)最低伤害
                x1 = (k * (z - 7) + a) * 1.5 < o6 ? (k * (z - 7) + a) : o6;
                o6 = o6 - x1 > 0 ? o6 - x1 : 0;

                DaFuBenMoNiGongju(b, z, a, m, o1, o2, o3, y, o4, o5, o6, x, x1, r, y1, k1, k2, k3, k4, k5, k6);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
                if (k2 == 1 && o2 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k2++;
                }
                if (k3 == 1 && o3 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫魔免最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k3++;
                }
                if (k4 == 1 && o4 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻有效)┉┉┉┉┉┉┉\n\n");
                    k4++;
                }
                if (k5 == 1 && o5 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效伤害(强命)┉┉┉┉┉┉┉\n\n");
                    k5++;
                }
                if (k6 == 1 && o6 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减魔攻有效最低伤害┉┉┉┉┉┉┉┉┉\n\n");
                    k6++;
                }
            }
            if (xz2 == 6) {
                DaFuBenMoNiCunJing(b, z, a, m, o1, k1);
                if (k1 == 1 && o1 <= 0) {
                    System.out.printf("┉┉┉┉┉┉┉全减免疫伤害(魔攻无效)┉┉┉┉┉┉┉\n\n");
                    k1++;
                }
            }
        }
    }


    //计算各种伤害

    // 计算/输出
    public static double JiShuan(int sum, int z, int qq, int zhiye, double q, double q1) {
        int e = sum * z + 1000000;
        double f = 0, g = 0, h = 0, i = 0, j = 0, l = 0, m = 0, a1 = 0;
        f = e * 1.5;
        //只有物理拥有魔免和强命伤害
        if (zhiye == 1) {
            g = f * 1.2 * 1.1 * 0.3;
            System.out.printf("魔免双状态伤害为:%.2f\n", g);
            a1 = g / z * (z - qq);
            System.out.printf("魔免双状态最低伤害为:%.2f\n", a1);
            System.out.printf("损失值:%.2f\n", g - a1);
            q = g * q1;
            System.out.printf("强命双状态伤害为:%.2f\n", q);
        }
        h = f * 0.3;
        System.out.printf("全减免疫伤害为:%.2f\n", h);
        if (zhiye == 1) {
            a1 = h / z * (z - qq);
            System.out.printf("全减免疫最低伤害为:%.2f\n", a1);
            System.out.printf("损失值:%.2f\n", h - a1);
            q = h * q1;
            System.out.printf("强命伤害为:%.2f\n", q);
        }
        i = f * 1.1 * 1.2;
        System.out.printf("刷伤害为:%.2f\n", f);
//        System.out.printf("刷伤害双状态为:%.2f\n",i);
        return i;
    }

    public static void JiShuanShuChu(int a, int b, int zhiye, int z, double q, double qm) {
        int sum = 0, qq = 0;
        //fhz承接每次刷伤害的值，用于计算刷伤害平均值
        double fhz = 0;
        System.out.println("\n");
        //武商均值
        sum = (a + b) / 2;
        System.out.println("本次武商均值为：" + sum);
        if (zhiye == 1) {
            //被格挡的次数
            qq = 7;
            System.out.println("被格挡的次数为：" + qq);
        }
        //伤害计算
        fhz = JiShuan(sum, z, qq, zhiye, q, qm);
        System.out.printf("刷伤害双状态为:%.2f\n", fhz);
        qq = 0;
        JiShuanDongTai(sum, z, qq);
    }

    //动态计算/输出
    public static void JiShuanDongTai(int sum, int z, int qq) {
        double j = 0, l = 0, m = 0;
        System.out.printf("\n\n");
        System.out.printf("完全狂暴:\n");
        System.out.printf("完全狂暴攻次为:24\n\n");
        z = z + 24;
        z = z <= 99 ? z : 99;
        m = (sum * (z - qq) + 1000000) * 1.5 * 1.2 * 1.1;

        System.out.printf("当前攻次为:%d\n", z);
        System.out.printf("完全狂暴伤害为:%.2f\n", m);
        System.out.printf("\n\n");

        System.out.printf("完全狂暴+狂暴术:\n");
        System.out.printf("狂暴术攻次为:7\n\n");

        z = z + 7 <= 99 ? z + 7 : 99;
        j = (sum * (z - qq) + 1000000) * 1.5 * 1.1 * 1.2;

        System.out.printf("当前攻次为:%d\n", z);
        System.out.printf("一个狂暴术伤害为:%.2f\n", j);
        z = z + 7 <= 99 ? z + 7 : 99;
        l = (sum * (z - qq) + 1000000) * 1.5 * 1.1 * 1.2;

        System.out.printf("当前攻次为:%d\n", z);
        System.out.printf("两个狂暴术伤害为:%.2f\n", l);
        z = z + 7 <= 99 ? z + 7 : 99;
        m = (sum * (z - qq) + 1000000) * 1.5 * 1.2 * 1.1;

        System.out.printf("当前攻次为:%d\n", z);
        System.out.printf("三个狂暴术伤害为:%.2f\n", m);
    }

    public static void JiShuanDongTaiShuChu(int jsxh, int z, int a, int b, int zhiye, double q, double qm) {
        int sum = 0, qq = 0;
        //fhz承接每次刷伤害的值，用于计算刷伤害平均值
        //shzz承接fhz的值，用于计算刷伤害平均值
        double fhz = 0, shzz = 0;

        for (int i = 1; i <= jsxh; i++) {
            System.out.println("\n");
            System.out.println("【第" + i + "次循环】");
            //武商均值
            sum = WuShangJunZhi(z, a, b);
            System.out.println("本次武商均值为：" + sum);
            //物理才有被格挡的资格
            if (zhiye == 1) {
                //被格挡的次数
                qq = GedangShengCheng(z);
                System.out.println("被格挡的次数为：" + qq);
            }
            //伤害计算
            fhz = JiShuan(sum, z, qq, zhiye, q, qm);
            shzz += fhz;
            System.out.printf("刷伤害双状态为:%.2f\n", fhz);
            JiShuanDongTai(sum, z, qq);
            max = WeMax(fhz);
            min = WeMin(fhz);
        }
        System.out.println("\n");
        System.out.println("您的最高武商为：" + a + "\n您的最低武商为：" + b);
        DanDuJunShang(a, b, z);
        System.out.printf("本" + jsxh + "次刷伤害双状态中最高伤害为：%.2f\n", max);
        System.out.printf("本" + jsxh + "次刷伤害双状态中平均伤害为：%.2f\n", (shzz / jsxh));
        System.out.printf("本" + jsxh + "次刷伤害双状态中最低伤害为：%.2f\n", min);
    }

    //刷伤害/输出
    public static double SuaSangHai(int sum, int qq, int z) {
        double m = 0;
        m = (sum * (z - qq) + 1000000) * 1.5 * 1.2 * 1.1;
        System.out.printf("刷伤害为:%.2f\n",m);
        return m;
    }

    public static void SuaShangHaiShuChu(int jsxh, int z, int a, int b, int zhiye) {
        int sum = 0, qq = 0;
        //fhz承接每次刷伤害的值，用于计算刷伤害平均值
        //shzz承接fhz的值，用于计算刷伤害平均值
        double fhz = 0, shzz = 0;
        for (int i = 1; i <= jsxh; i++) {
            System.out.println("【第" + i + "次】");
            //武商均值
            sum = WuShangJunZhi(z, a, b);
            System.out.println("本次武商均值为：" + sum);
            //物理才有被格挡的资格
            if (zhiye == 1) {
                //被格挡的次数
                qq = GedangShengCheng(z);
                System.out.println("被格挡的次数为：" + qq);
            }
            //伤害计算
            fhz = SuaSangHai(sum, qq, z);
            shzz += fhz;
            System.out.printf("刷伤害为:%.2f\n", fhz);
            max = WeMax(fhz);
            min = WeMin(fhz);
        }
        System.out.println("\n");
        System.out.println("您的最高武商为：" + a + "\n您的最低武商为：" + b);
        DanDuJunShangShua(a, b);
        System.out.printf("本" + jsxh + "次刷伤害中最高伤害为：%.2f\n", max);
        System.out.printf("本" + jsxh + "次刷伤害的平均伤害为：%.2f\n", (shzz / jsxh));
        System.out.printf("本" + jsxh + "次刷伤害中最低伤害为：%.2f\n", min);
    }

    //创建静态最大最小值
    static double max = 0;

    public static double WeMax(double fhz) {
        if (max < fhz) {
            max = fhz;
        }
        return max;
    }

    static double min = 0;
    //创建一个中间循环值用于最小值的获取
    static int i = 0;

    public static double WeMin(double fhz) {
        for (; i < 1; i++) {
            min = fhz;
        }
        if (min > fhz) {
            min = fhz;
        }
        return min;
    }

    //平均武商双状态伤害
    public static void DanDuJunShang(int a, int b, int z) {
        double sh = ((a + b) / 2 * z + 1000000) * 1.5 * 1.2 * 1.1;
        System.out.printf("武商均值刷伤害伤害为：%.2f\n", sh);
    }

    //平均武商刷伤害
    public static void DanDuJunShangShua(int a, int b) {
        int z = 99;
        double sh = ((a + b) / 2 * z + 1000000) * 1.5 * 1.2 * 1.1;
        System.out.printf("武商均值刷伤害伤害为：%.2f\n", sh);
    }
}